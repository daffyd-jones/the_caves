use crate::enums::{Cells, Door, EnvInter, FeatureType, NPCWrap};
use crate::item::{rand_hermit_item, Item};
use crate::npc::{new_comm_npc, new_conv_npc, new_shop_npc, Convo, ShopConvos, ShopData};
use rand::prelude::SliceRandom;
use rand::Rng;
use std::collections::HashMap;
use std::f64::consts;
use std::fs;

const STREAM: &str = r#"
________________
________________
________________
________________
________________
________________
________________
________________
"#;

const PALETTE: &str = r#"
empty: ' . , ' * |
wall: ▒ |
other ▓ ░ ~ |
pipes:
═ ║ ╣ ╠ ╩ ╦ ╗ ╝ ╚ ╔ ╬
┐ └ ┴ ┬ ├ ─ ┼ ┘ ┌ ┤ │
ʬ ỻ Π Ħ ʭ ṑ ⑁                   
ж ѧ π
ᘉ ᘈ ᘍ ᘊ
≡ ° × ¤ ¸ ¨ · ■ ¦ ± ¡ ø Ø ©
"#;

const HERMIT_1: &str = r#"
__________
_____─┬─__
_____o│o__
_____o│o__
__x__─┴─__
__________
"#;

const HERMIT_2: &str = r#"
__________
____┌───┐_
____│o_o│_
____│o_o│_
__x_└___┘_
__________
"#;

const STREAM_SOURCE_L: &str = r#"
################
___________#####
_~~~~____╔╦╗____
~~~~~~~~~~~╣_###
~~~~~~~~~~╦╣_###
~____~~~_____###
___________#####
##########_#####
"#;

const STREAM_SOURCE_R: &str = r#"
################
####____________
####_╔╦╗__~~~~__
####_╠~~~~~~~~~~
####_╠╦~~~~~~~~~
________~~~__~~~
#######_________
################
"#;

const STREAM_SOURCE_B: &str = r#"
################
####________####
______╔╦╦╗__####
####__╠~~╣___###
####__~~~~__####
###__~~~~~__####
####_~~~~~~__###
####__~~~~~_####
"#;

const STREAM_SOURCE_U: &str = r#"
###__~~~~~__####
####_~~~~~~__###
###___~~~~~_####
####__~~~~__####
####__╣~~╠___###
###___╚╦╦╝__####
####____________
################
"#;

const STREAM_TRANS: &str = r#"
################
################
################
################
################
################
################
################
"#;

const STREAM_UR: &str = r#"
####__~~~~__####
####__~~~~______
###__~~~~~__~~~_
###__~~~~~~~~~~~
####__~~~~~~~~~~
###_____~~~~____
####____________
################
"#;

const STREAM_UL: &str = r#"
####__~~~~__####
#_#____~~~~__###
______~~~~~__###
~~~_~~~~~~~__###
~~~~~~~~~~__####
__~~~~~______###
____________####
################
"#;

const STREAM_BL: &str = r#"
################
_________#######
__~~~~~____#####
~~~~~~~~~~__####
~~~__~~~~~~__###
______~~~~~__###
##___~~~~~~__###
###___~~~~__####
"#;

const STREAM_BR: &str = r#"
################
#######_________
#####____~~~~___
####___~~~~~~~~~
####__~~~~~~~~~~
###__~~~~~______
###__~~~~____###
####__~~~~__####
"#;

const STREAM_VERT: &str = r#"
####__~~~~__####
###__~~~~~__####
###__~~~~~~__###
###__~~~~~~__###
####__~~~~~__###
###__~~~~~~__###
###__~~~~~__####
####__~~~~__####
"#;

const STREAM_HORZ: &str = r#"
################
#______#_______#
__~~~~___~~~~~__
~~~~~~~~~~~~~~~~
~~~~~~~~~~~~~~~~
_____~~~~~______
###________#####
################
"#;

#[derive(Clone, PartialEq, Eq, Copy, PartialOrd, Ord)]
enum Stream {
    Horz,
    Vert,
    SourceU,
    SourceB,
    SourceL,
    SourceR,
    UR,
    UL,
    BL,
    BR,
    Trans,
    Null,
}

const STREAM_UP_FULL: [Stream; 4] = [Stream::Vert, Stream::BL, Stream::BR, Stream::SourceB];

const STREAM_UP_EMPTY: [Stream; 7] = [
    Stream::Horz,
    Stream::UR,
    Stream::UL,
    Stream::Trans,
    Stream::SourceU,
    Stream::SourceR,
    Stream::SourceL,
];

const STREAM_LEFT_FULL: [Stream; 4] = [Stream::Horz, Stream::UR, Stream::BR, Stream::SourceR];

const STREAM_LEFT_EMPTY: [Stream; 7] = [
    Stream::Vert,
    Stream::UL,
    Stream::BL,
    Stream::Trans,
    Stream::SourceU,
    Stream::SourceB,
    Stream::SourceL,
];

fn build_stream() -> String {
    let mut rng = rand::thread_rng();
    let mut cells = vec![vec![' '; 128]; 64];
    let mut temp = vec![vec![Stream::Trans; 8]; 8];
    // temp[0][0] = Field::OutCornerUL;
    for j in (0..temp.len()) {
        for i in (0..temp[0].len()) {
            let up = if j > 0 { temp[j - 1][i] } else { Stream::Null };
            let left = if i > 0 { temp[j][i - 1] } else { Stream::Null };
            temp[j][i] = {
                match (up, left) {
                    (Stream::Null, Stream::Null) => *[Stream::SourceB, Stream::SourceR]
                        .choose(&mut rng)
                        .unwrap_or(&Stream::SourceB),
                    (up, right) if j == temp.len() - 1 && i == temp[0].len() - 1 => {
                        if STREAM_UP_FULL.contains(&up) {
                            Stream::SourceU
                        } else if STREAM_LEFT_FULL.contains(&right) {
                            Stream::SourceL
                        } else {
                            Stream::Trans
                        }
                    }
                    (Stream::Null, left) => {
                        if i == temp[0].len() - 1 && STREAM_LEFT_FULL.contains(&left) {
                            Stream::BL
                        } else if i == temp[0].len() - 1 && STREAM_LEFT_EMPTY.contains(&left) {
                            Stream::Trans
                        } else if STREAM_LEFT_FULL.contains(&left) {
                            *[Stream::Horz, Stream::BL]
                                .choose(&mut rng)
                                .unwrap_or(&Stream::Horz)
                        } else {
                            Stream::Trans
                        }
                    }
                    (up, Stream::Null) => {
                        if j == temp.len() - 1 && STREAM_UP_FULL.contains(&up) {
                            Stream::UR
                        } else if j == temp.len() - 1 && STREAM_UP_EMPTY.contains(&up) {
                            Stream::Trans
                        } else if STREAM_UP_FULL.contains(&up) {
                            *[Stream::Vert, Stream::UR]
                                .choose(&mut rng)
                                .unwrap_or(&Stream::Vert)
                        } else {
                            Stream::Trans
                        }
                    }
                    (up, left) if i == temp[0].len() - 1 => {
                        if STREAM_UP_FULL.contains(&up) && STREAM_LEFT_FULL.contains(&left) {
                            Stream::UL
                        } else if STREAM_UP_FULL.contains(&up) && STREAM_LEFT_EMPTY.contains(&left)
                        {
                            Stream::Vert
                        } else if STREAM_UP_EMPTY.contains(&up) && STREAM_LEFT_FULL.contains(&left)
                        {
                            Stream::BL
                        } else {
                            Stream::Trans
                        }
                    }
                    (up, left) if j == temp.len() - 1 => {
                        if STREAM_UP_FULL.contains(&up) && STREAM_LEFT_FULL.contains(&left) {
                            Stream::UL
                        } else if STREAM_UP_EMPTY.contains(&up) && STREAM_LEFT_FULL.contains(&left)
                        {
                            Stream::Horz
                        } else if STREAM_UP_FULL.contains(&up) && STREAM_LEFT_EMPTY.contains(&left)
                        {
                            Stream::UR
                        } else {
                            Stream::Trans
                        }
                    }
                    (up, left)
                        if STREAM_UP_FULL.contains(&up) && STREAM_LEFT_FULL.contains(&left) =>
                    {
                        Stream::UL
                    }
                    (up, left)
                        if STREAM_UP_FULL.contains(&up) && STREAM_LEFT_EMPTY.contains(&left) =>
                    {
                        *[Stream::Vert, Stream::UR]
                            .choose(&mut rng)
                            .unwrap_or(&Stream::Vert)
                    }
                    (up, left)
                        if STREAM_UP_EMPTY.contains(&up) && STREAM_LEFT_FULL.contains(&left) =>
                    {
                        *[Stream::Horz, Stream::BL]
                            .choose(&mut rng)
                            .unwrap_or(&Stream::Horz)
                    }
                    (up, left)
                        if STREAM_UP_EMPTY.contains(&up) && STREAM_LEFT_EMPTY.contains(&left) =>
                    {
                        *[Stream::SourceB, Stream::SourceR, Stream::Trans, Stream::BR]
                            .choose(&mut rng)
                            .unwrap_or(&Stream::Trans)
                    }
                    _ => Stream::Trans,
                }
            }
        }
    }
    for j in 0..temp.len() {
        for i in 0..temp[0].len() {
            let patch = match temp[j][i] {
                Stream::Horz => STREAM_HORZ,
                Stream::Vert => STREAM_VERT,
                Stream::SourceU => STREAM_SOURCE_U,
                Stream::SourceB => STREAM_SOURCE_B,
                Stream::SourceL => STREAM_SOURCE_L,
                Stream::SourceR => STREAM_SOURCE_R,
                Stream::UL => STREAM_UL,
                Stream::UR => STREAM_UR,
                Stream::BL => STREAM_BL,
                Stream::BR => STREAM_BR,
                Stream::Trans => STREAM_TRANS,
                _ => todo!(),
            };
            let patch_chars = tile_to_chars(patch);
            for y in 0..8 {
                for x in 0..16 {
                    cells[j * 8 + y][i * 16 + x] = patch_chars[y][x];
                }
            }
        }
    }
    std::iter::once("Null|Null|Null".to_string())
        .chain(cells.iter().map(|row| row.iter().collect::<String>()))
        .collect::<Vec<String>>()
        .join("\n")
}

const GRASS_PATCH: &str = r#"
',',',',',',',',
',",',',',',",',
',',',',',',',',
',',',",',',',',
',',',',',',',',
',",',',',',',',
',',',',',",',',
',',',',',',',',
"#;

const GRASS_PATCH_TRANS: &str = r#"
',',',',',',',',
',",',',',',",',
',',',###,',',',
',','#####',',',
',',#####,',',',
',",'###',',',',
',',',',',",',',
',',',',',',',',
"#;

const GRASS_EMPTY: &str = r#"
________________
________________
_____"__________
________________
_____________'__
__,_____________
___________*____
________________
"#;

const GRASS_EMPTY_TRANS: &str = r#"
####______######
####________####
###__"________##
________________
_____________'__
__,_____________
###________*____
####____________
"#;

const GRASS_IN_CORNER_UL: &str = r#"
',',',',',',',',
',",',',',',",',
',',',',',',',',
',',',",'_','_',
',',','______,__
',",','__,______
',',',",______'_
',',','____*____
"#;

const GRASS_IN_CORNER_BL: &str = r#"
',',',',__._____
',",','_____,___
',',',",________
',',','__"_____.
',',',",_,',_,',
',',',',',',',',
',",',',',',",',
',',',',',',',',
"#;

const GRASS_IN_CORNER_UR: &str = r#"
',',',',',',',',
',',",',',',",',
',',',',',',',',
'_','_',",',',',
_,___.__',',',',
___,____',',",',
_______"_,',',',
__,___,_',',',',
"#;

const GRASS_IN_CORNER_BR: &str = r#"
_,______',',',',
___"____',',",',
______.__,',',',
__'_____',',',',
',',_,',",',',',
',',',',',',',',
',',",',',',",',
',',',',',',',',
"#;

const GRASS_OUT_CORNER_UL: &str = r#"
________________
_,____'______"__
__________,_____
___._____,_,_,__
_,_____,',",','"
_______,',',',',
____"___',",',',
_______,',',',',
"#;

const GRASS_OUT_CORNER_BL: &str = r#"
_______,',",',',
_"_____,',',',',
____.__,',",',',
________',',',',
__'______'__'_'_
______._________
____________,___
___"____._______
"#;

const GRASS_OUT_CORNER_BR: &str = r#"
',',',','_______
',',',",_____"__
',",',','_,_____
',',',',________
_'__'_'_______._
________,_______
_"__________,___
_____.__________
"#;

const GRASS_OUT_CORNER_UR: &str = r#"
________________
__,__________,__
_______"________
_,__,_,____'____
',',',','_______
',',',",______,_
',",',','_._____
',',',',________
"#;

const GRASS_HORZ_U: &str = r#"
__,_____________
_____._____'____
_'____________"_
________"_______
',',',_,',',','_
',",',',',',',',
',',',',',",',',
',',',',',',',',
"#;

const GRASS_HORZ_B: &str = r#"
',",',',',',',',
',',',',',",',',
',',',',',',',',
',',',_,',',','_
_______.________
_"________,_____
______________"_
_____'___.______
"#;

const GRASS_VERT_L: &str = r#"
_______,',',',',
_,_____,',',",',
____"__,',',',',
________',',',',
__'____,',',',',
_____._,',',',',
________',",',',
___'___,',',',',
"#;

const GRASS_VERT_R: &str = r#"
',',',','_______
',',",',__.___'_
',',',','_______
',',',',"___"___
',',',','_____,_
',',',',__,_____
',",',','____'__
',',',','_______
"#;

const SHRUB_PATCH: &str = r#"
',',',',',',',',
',",'&&&',',",',
','&&&&&&&',',',
',&&&&&&&&',',',
','&&&&&&&&,',',
',",'&&&&,',',',
',',',',',",',',
',',',',',',',',
"#;

// Hermit

// const HERMIT_BLANK: &str = r#"Null|Null|Null
// ________________________________________
// ________________________________________
// ________________________________________
// ________________________________________
// ________________________________________
// ________________________________________
// ________________________________________
// ________________________________________
// ________________________________________
// ________________________________________
// ________________________________________
// ________________________________________
// "#;

// const HERMIT_1: &str = r#"Null|Null|Null
// ________________________________________
// ________________________________________
// ________________________________________
// ________________________________________
// ______________________┌────────┐________
// _______________________________│________
// _______________________________│________
// __________________________H____┘________
// ________________________________________
// ________________________________________
// ________________________________________
// ________________________________________
// "#;

// Construction

const CONSTRUCTION_BLANK: &str = r#"Null|Null|Null
________________________________________
________________________________________
________________________________________
________________________________________
________________________________________
________________________________________
________________________________________
________________________________________
________________________________________
________________________________________
________________________________________
________________________________________
"#;

/*
 🬐🬑  🝗  🝠

 🬮 🬡
*/

const PALETTE1: &str = r#"
empty: ' . , ' * |
wall: ▒ |
other ▓ ░ ~ |
pipes:
═ ║ ╣ ╠ ╩ ╦ ╗ ╝ ╚ ╔ ╬
┐ └ ┴ ┬ ├ ─ ┼ ┘ ┌ ┤ │
ʬ ỻ Π Ħ ʭ ṑ ⑁                   
ж ѧ π
ᘉ ᘈ ᘍ ᘊ
≡ ° × ¤ ¸ ¨ · ■ ¦ ± ¡ ø Ø ©
"#;

const CONSTRUCTION_1: &str = r#"CommNPC CommNPC CommNPC CommNPC CommNPC|Null|Null
######░░░░░░░░░░▓▓▓▓  . ,  C ·  ▓▓▓▓####
######░░░░░░░░░░▓▓▓▓┬┬┬┬┬┐┌┬┬┬┬┬▓▓▓▓▓▓##
░░░░░░░🬗░░░░░░░░▓▓🬐🬑        '  │▓▓▓▓▓▓##
░░░░░░░░░░░░░░░░▓▓🬮🬡@      *   │▓▓▓▓▓▓##
,   ░░░░     ·, │ @ ··'   ·    ├┬┬┬┐▓▓##
    ░░░░     ,  │   ,   ·   ⑁  ┌─┐ │▓▓##
.  ·░░░░ *.     ├┬┬┐    @ ѧ  ⑁ ├╦┤ ├▓▓##
    ░░░░   '   , , ├┬┬┐   ' ,,   @  ▓▓##
,   ░░░░   . ,      * ├┐┌┐     @🬮🬡🬑▓▓🬗▓▓
    ░░░░   .          C  ├┬┬┐ · ▓▓▓▓🬗▓▓▓
    ░░░░                '   ├┬┬┬▓▓▓▓▓🬗▓▓
    🬁░░░               , ·      ▓▓▓▓▓▓▓▓
"#;

const CONSTRUCTION_2: &str = r#"CommNPC CommNPC CommNPC CommNPC CommNPC CommNPC|Null|Null
' ######### 🬞▓▓▓     C   '  ▓▓▓▓▓▓▓▓▓▓▓🭏
##        , ▓▓▓▓┌┬┬┬┬┐┌┬┬┬┬┐▓▓▓▓▓▓▓▓▓▓▓▓
## *        ▓▓▓▓         .  ▓▓▓▓▓▓▓▓▓▓▓▓
##.         ▓▓🬑🬗   @  ⑁    @🬑▓▓▓▓▓▓▓▓▓▓▓
##       , '▓▓▓🬡     ѧ ⑁    🬡🬮▓▓   ·    
##          ▓▓▓🬗@   ▓▓▓🭏   @🬦▓▓▓    '   
##          ▓▓▓▓π@  ▓▓▓▓··  ▓▓▓▓   .  , 
## *    '   ▓▓▓▓,   ▓▓▓▓   ·🬡🬗▓▓        
▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓·  @🬑▓▓▓▓▓▓▓▓▓▓🬿
▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓   *▓▓▓▓▓▓▓▓▓▓▓▓
▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓┌┬┬┐▓▓▓▓▓▓▓▓▓▓▓▓
▓▓▓▓▓▓▓ඉ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓🭠 C  ▓▓▓▓▓▓▓▓▓▓▓▓
"#;

const CONSTRUCTION_3: &str = r#"CommNPC CommNPC CommNPC CommNPC CommNPC|Null|Null
## '   ,,    '   ,,#########▓▓▓▓   *▓▓▓▓
## . ,    * *           ▓▓▓▓▓🬗▓▓▓▓▓▓▓▓▓▓
## .                *  ·▓▓▓▓🬗▓▓▓▓▓▓▓▓▓▓▓
##          '        ┌┬┐▓▓▓▓▓🬗▓▓▓▓▓▓▓▓▓▓
##              ,C·┌┬┤  ▓▓🬡🬑🬑▓▓▓▓▓▓▓▓▓▓ඉ
.'     ,   ,  ┌┬┐┌┬┤   Ʌ .@ 🬮▓▓▓    ▓▓▓▓
            ┌┬┤             ▓▓▓▓    ▓▓▓▓
   *      ┌┬┤        ѧ ⑁ '' 🬑▓▓▓  . ▓▓▓▓
     · ,  │  *  @  @     @ @🬗▓▓▓.   ▓▓▓▓
▒▒▒▒▒▒▒▒▓▓▓▓▓▓▓🬑🬡🬑🬗🬑🬮▓▓▓🬑🬮🬡🬮🬑▓▓▓ *  ▓▓▓▓
▒▒▒▒▒▒▒▒▓▓▓▓▓▓▓▓🬑🬮🬡▓▓▓▓▓▓▓▓▓▓▓▓▓    ▓▓▓▓
▒▒▒▒▒▒▒▒▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓    ▓▓▓▓
"#;

const CONSTRUCTION: [&str; 3] = [CONSTRUCTION_1, CONSTRUCTION_2, CONSTRUCTION_3];

// Abandoned shacks

const ABANDONED_SHACK_BLANK: &str = r#"Null|Null|BronzeWarAxe
________________________________________
________________________________________
________________________________________
________________________________________
________________________________________
________________________________________
________________________________________
________________________________________
________________________________________
________________________________________
________________________________________
________________________________________
"#;

const ABANDONED_SHACK_1: &str = r#"Null|Null|BronzeWarAxe
###___________________________________##
______________________________________##
____▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒___',___,',',____##
____▒_π____│________▒___',",',',',____##
____▒_____O│______.¨≡°___,',',",',._____
____▒───_──┘________▒___',',',',',."____
____▒_______________▒___',",',',",'_____
#___▒▒▒▒▒▒▒▒▒▒__▒▒▒▒▒____,',",',','_____
#____________"__",_____,',',',',',,_____
#_____.ѧ._____________',',",',',",'_____
#_____"*'_____________',",',',',',______
#_______________________________________
"#;

const ABANDONED_SHACK_2: &str = r#"Null|Null|BronzeGreatsword
#####__________________________________#
__,______.,"__,___________________,__._#
_"┌┬┬┬┬┬┬┬┬┬┐_____'__▒▒▒▒▒▒▒▒▒▒▒▒▒▒,___#
__├",*______┤__,_____▒_________≡≡_▒_____
__├',"______┤_____,"_▒____________▒_____
__├'________┤________▒___┌──┬──___▒___"_
__├_________┤___'____▒___│__2_____▒_____
__├┬┬┬┬┐_┌┬┬┤_"__________├──┘__≡≡O▒__,__
#_._____________'____▒___│_____≡≡≡▒_____
#_______,__.__*______▒___│____≡≡≡_▒,____
#___'____._______.___▒▒▒▒▒▒▒▒▒▒▒▒▒▒",___
_"__________.______*_______"",'___""____
"#;

const ABANDONED_SHACK_3: &str = r#"Null|Null|BronzeGreatsword
________________#########_______________
_,______Ʌ___Ʌ_______'___,__:┌─────┐:_,__
_____ж_Ʌ_________,_________:│~~~~~│:____
__"__жж__ѧ___Ʌ________"____:│~~~~~│:__'_
_,__________Ʌ___________.__:│~~~~~│:____
_"▒▒▒▒▒▒▒▒▒,____,",',',____:└─────┘:_,__
__▒O__│___▒"____,',',",',_____±_±______#
__▒___│___▒_____,',',',',',',_,_,_,',__#
_,▒─__┘_________,",',',",",',',",",',__#
__▒≡_____≡▒__'__,',",',',',",',',',"____
_,▒▒▒▒▒▒▒▒▒,_____',',',',',',',',','__'_
_____'____"_____________________________
"#;

const ABANDONED_SHACK_4: &str = r#"Null|Null|BronzeGreatsword
______________,___________._____########
_ʬʬʬʬʬʬʬʬʬʬʬ___________,________________
_ʬʬ,ʬʬʬʬʬʬʬʬ____._____"▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒"_
_ʬʬʬʬʬʬʬʬʬʬʬ___________▒_____│_______▒__
_ʬʬʬʬʬʬʬ"ʬʬʬ_┤_____,___▒__________π__▒,_
_ʬʬʬʬʬʬʬʬʬʬʬ_┤_________▒O____│_______▒__
_ʬʬʬʬʬʬʬʬʬʬʬ_┤_________▒─────┼────_──▒__
_ʬʬʬ.ʬʬʬʬʬʬʬ_┤_______________________▒,_
_ʬʬʬʬʬʬʬʬʬʬʬ_┤__"______▒_____│_____≡≡▒__
_ʬʬʬʬʬʬʬʬʬʬʬ_┤________,▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒__
_______┌┬┬┬┬┬┤____.____'___________'"___
###______,________________._____________
"#;

const ABANDONED_SHACK_5: &str = r#"Null|Null|BronzeLightAxe BronzeGreatsword
#_____________________________________##
_,.~~~~,__________,____________________#
_"~~~~~~~,__________ʭΠỻΠỻΠΠỻΠỻΠʭ____.___
_~~~~~~~~~,___╔═══╗_ʭ________O_ʭ________
_~~~~~~~~~.___D___║_ʭ__________ʭ________
_~~~~~~~~~~___║__O║_ʭ__________ʭ________
_"~~~~~~~~~'__╚═══╝_ʭ__________ʭ________
__,~~~~~~~,_________ỻΠỻΠĦ__ĦΠỻΠỻ________
___.~~~~~,.______________________,______
_______'"______"________________________
_______________________________________#
##_____________________________________#
"#;

const ABANDONED_SHACK_6: &str = r#"Null|Null|BronzeClaymore
##########__________#####____________###
##_______'____________'____________,_###
##_____________,_____╔═══════╤═════╗____
#___'┌┬┬┬┬┬┬┬┬┬┐'____║_______│____O║____
_____├ᘉᘊᘉᘊ_&&&&┤_____║____│________║___#
_____├ᘈᘉᘈᘍ&&&&&┤_____║π_⑁_│__│____🁢║___#
___._├_ᘈᘍᘈ_&&&_┤_____╟────┘__│_____║"___
_____├__ᘉ______┤"____║______╔╧═════╝____
_____├┬┬┬┐_┌┬┬┬┤_____║≡≡≡_______,_____##
#___________________,╚══════╝_________##
#__________________________________#####
#####________#######______________######
"#;

const ABANDONED_SHACK_7: &str = r#"Null|Null|BronzeClaymore
##########__________#####____________###
##_________________________________,_###
##__╔═══╤═════════╗_____________________
#___║O__│____π⑁___║'____________________
____║_____________║_______,____________#
____║🁢__│__╔══════╝______'~~~~~~~._____#
___.╟───┘__║______"______~~~~~~~~~______
____║____________________~~~~~~~~~______
____║___≡≡≡║___,_________~~~~~~~~_____##
#___╚══════╝______________~~~~~~______##
#__________________________________#####
#####________#######______________######
"#;

const ABANDONED_SHACK_8: &str = r#"Null|Null|BronzeClaymore
##########__________#####____________###
##_________________________________,_###
##_____.┌───┐_______.___________________
#_______│__O│,____________┌──────┐______
_______'└─_─┘.____________│,'_".'│_____#
____________"___________'╔╧══════╧╗____#
___________╭────────╮____║π_____≡≡║_____
____'______│~~~~~~~~│_______┌─_───║_____
___________│~~~~~~~~│,___║_ṑ│___🁢_║___##
#_______"__╰────────╯____╚══╧═════╝___##
#__*___________________________'___#####
#####________#######______________######
"#;

const ABANDONED_SHACK_9: &str = r#"Null|Null|MediumArmour Shroom
##########__________#####____________###
##________________,__________________###
##__▒▒▒▒▒▒▒▒▒▒▒▒▒▒'____┌┬┬┬┬┤_├┬┬┬┬┐____
#___▒O____│______▒_____├ᘈᘉᘊᘍ"__,"ᘉᘊ┤____
____▒____🁢│____⑁_▒_____├ᘉᘈᘍᘊ&&._ᘊᘈᘍ┤___#
___"▒──_──┤____π_▒____.├ᘊᘉ_&&&&,_Oᘊ┤___#
____▒____________▒_____├┬┬┬┬┬┬┬┬┬┬┬┤____
____▒▒▒▒▒▒▒_▒▒▒▒▒▒"_____________________
______________________ঌ_______________##
#______________.______ѧ_________"_____##
#__*_______________________________#####
#####________#######______________######
"#;

const ABANDONED_SHACK_10: &str = r#"Null|Null|IronLightAxe HealthPotion Apple
##########__________#####____________###
##┌┬┬┬┬┬┬┬┬┬┬┬┬┬┬┬┬┬┬┬┬┬┬┬┬┬┬┬┬┬┬┬┬┬┬┐##
##├ʬʬʬᘍʬʬʬʬʬʬʬʬʬʬʬʬʬʬʬʬʬʬʬʬʬʬʬʬʬʬʬʬʬᘍ┤__
#_├ʬᘈʬʬʬᘊᘈᘉᘍʬᘊᘈᘉᘍ╔═══════╤═══╗ᘉᘊᘈʬᘉᘊᘈ┤__
__├ʬ&&ᘉᘊʬʬʬʬᘈ&&ʬʬ║_______│O_≡║ʬʬʬʬᘉᘊ&┤__
__├ʬʬʬʬʬʬᘉᘊᘈᘉʬʬʬʬ╟─────_─┤🁢__║ʬ&ʬʬʬᘈᘉ┤_#
_'├╭───╮ʬʬʬʬʬʬᘈᘉᘊ║π⑁_____└─_─╢ʬᘍᘉᘉᘊᘈʬ_.#
__├│~~~│ʬᘊᘈᘉᘉᘊᘈʬO║_╔═_═╗_____║ʬʬʬᘊᘈᘉʬ┐__
__├│~~~│ʬʬ&ʬᘊᘈᘉʬ&╚═╝:·:╚═════╝&ʬʬᘊᘈʬʬ┤##
#_├╰───╯&ʬʬʬʬʬʬʬʬʬʬʬʬʬʬʬʬʬʬʬʬOᘉᘊʬʬʬʬᘍ┤_#
#_├┬┬┬┬┬┬┬┬┬┬┬┬┬┬┬┬┬┬┬┬┬┬┬┬┬┬┬┬┐&┌┬┬┬┤_#
#####________#######_"____________######
"#;

const ABANDONED_SHACK_11: &str = r#"Null|Null|HeavyArmour ShadowAxe
##########__________#####____________###
##┌┬┬┬┬┬┬┬┬┬┬┬┬┬┬┬┬┬┬┬┬┬┬┬┬┬┬┬┬┬┬┬┬┬┬┐##
##├ʬʬʬᘍʬʬʬʬʬʬʬʬʬʬʬʬʬʬʬʬʬʬʬʬʬʬʬʬʬʬʬʬʬᘍ┤__
#_├ʬᘈʬʬʬ╔═══╤═══════╗ᘊᘈᘉᘍʬᘊᘈᘉᘍᘉᘊᘈʬᘉᘊᘈ┤__
__├ʬ&&ᘉᘊ║__≡│______O║ʬʬʬʬᘈ&&ʬʬʬʬʬʬᘉᘊ&┤__
__├ʬʬʬᘉᘈ║🁢__├─_─────╢ʬᘉᘊᘈᘉʬʬʬʬ&&ʬ┌┬┬┬┤_#
_'├&&ʬʬʬ╟─_─┘_______║ʬʬʬʬʬʬᘈᘉᘊᘈᘍ&&____.#
__├ᘍᘈᘍᘈʬ║_______╔═_═╝ʬᘊᘈᘉᘉᘊᘈʬʬʬʬʬ┌┐_┌┐__
__├ᘉᘊᘉᘊO╚═══════╝:·:·ʬ&&ʬᘊᘈᘉʬ&&ʬʬᘊᘈʬʬ┤##
#_├ᘉᘈᘉᘈᘍ&ʬʬʬʬʬʬʬʬʬʬʬʬʬʬʬʬʬʬʬʬʬᘉᘊʬʬʬʬᘍ┤_#
#_├┬┬┬┬┬┬┬┬┬┬┬┬┬┬┬┬┬┬┬┬┬┬┬┬┬┬┬┬┬┬┬┬┬┬┤_#
#####________#######_"____________######
"#;

const ABANDONED_SHACK_12: &str = r#"Null|Null|SteelHeavyAxe HeavyArmour
##########__________#####____________###
##_________,________'╔══════╤═══════╗###
##┌┬┬┬┬┬┬┬┬┬┬┬┐______║_____O│_____≡≡║___
#_├ᘉᘊᘈᘍᘉᘊᘈᘉᘊᘈᘍ┤______║🁢_____├─_─┬───╢___
__├ᘊᘈᘍᘉʬʬ".',"┤______╟──_───┘___D__O║__#
__├,&&&ʬʬʬ┌┐_┌┤______║__________└───╢._#
__├&&ʬʬʬ&&┤__________╚══_═╗__π⑁___≡≡║___
__├&&ʬ.&ᘉᘊ┤_╭────╮___:·:·:╚═════════╝___
__├ʬʬ&ᘉᘊᘈᘍ┤_╰╮~~~╰────╮_______"_______##
#_├┬┬┬┬┬┬┬┤_'╰╮~~~~~~~│_____ঌ_________##
#_____________╰───────╯_____ѧ______#####
#####________#######_"____________######
"#;

const ABANDONED_SHACK_13: &str = r#"Null|Null|HeavyArmour
##########__________#####____________###
##╔════╤══╤═══════╗___'____________,_###
##║___O│__│_______║┌┬┬┬┬┬┬┬┬┬┬┬┐________
#_║🁢___│__________║├ᘉᘊᘈᘍᘉᘊᘈᘍᘉᘊᘈ┤________
_.║____│__│_╔═_═══╝├______"ᘊᘈᘍᘉ┤'______#
__╟──_─┘__└─╢:·:·:·├┐_┌┐,___ʬʬʬ┤_______#
__║π⑁_____≡≡║:·:·:·____├ʬʬʬʬ&&ᘈ┤________
__╚═════════╝__________├ʬʬ.&&ᘉᘊ┤________
___"___________ঌ______.├ʬʬ&ᘉᘊᘈᘍ┤"_____##
#______________ѧ_______├┬┬┬┬┬┬┬┤______##
#_______________________'__________#####
#####________#######______________######
"#;

const ABANDONED_SHACK_14: &str = r#"Null|Null|IronHeavyAxe
##########__________#####____________###
##_________*_________.╭───────────╮_,###
##_____ঌ______________╰╮~~~~~~~~~~╰╮____
#______ѧ___,__________'╰╮~~~~~~~~~~│____
__╔══════╤══╗:·:·:·_____╰─────╮~~~~│___#
_"║π⑁____│__║:·:·:·___________╰────╯"__#
__║_________╚══_══╗┌┬┬┐_┌┬┬┐____________
__╟──_───┐________║├ʬʬʬʬ&&ᘈ┤,___________
__║______│________║├ʬʬ.&&ᘉᘊ┤__________##
#_║🁢_____│O___≡≡≡≡║├ʬʬ&ᘉᘊᘈᘍ┤__________##
#_╚══════╧════════╝├┬┬┬┬┬┬┬┤_______#####
#####___'____#######______________######
"#;

const ABANDONED_SHACK_15: &str = r#"Null|Null|HeavyArmour SteelHeavyAxe
##########__________#####____________###
##╔═══════╤═══════╗___'____________,_###
##║≡≡_____│±°×°±_ṑ║_____┌┬┬┬┬┬┬┬┬┬┬┬┐___
#_║____│__________║_____├ᘉᘊᘈᘍᘉᘊᘈᘍ&&&┤___
__║_π_O│__│_╔═_═══╝·____├&&ᘉᘊᘈᘍᘉᘊᘈᘍ&┤__#
__╟────┘__└─╢:·:·:·:·:__├ʬʬʬʬʬʬʬʬ&&&┤__#
__║______⑁__║:·:·:·:·:__├ʬʬ.ʬʬʬʬʬʬʬʬ┤___
__╟──_──┐___╚═════╗·____├ʬʬʬʬʬʬʬʬ,ʬʬ┤___
__║_____│_________║_____├ʬʬʬʬʬʬʬʬʬʬʬ┤_##
#_║🁢___O│≡≡≡≡___ṑṑ║_____├┬┬┬┬┐_┌┬┬┬┬┤_##
#_╚═════╧═════════╝________________#####
#####________#######______________######
"#;

const ABANDONED_SHACKS: [&str; 15] = [
    ABANDONED_SHACK_1,
    ABANDONED_SHACK_2,
    ABANDONED_SHACK_3,
    ABANDONED_SHACK_4,
    ABANDONED_SHACK_5,
    ABANDONED_SHACK_6,
    ABANDONED_SHACK_7,
    ABANDONED_SHACK_8,
    ABANDONED_SHACK_9,
    ABANDONED_SHACK_10,
    ABANDONED_SHACK_11,
    ABANDONED_SHACK_12,
    ABANDONED_SHACK_13,
    ABANDONED_SHACK_14,
    ABANDONED_SHACK_15,
];

const SMALL_RUIN_1: &str = r#"Null|Null|Null
###___________________##########____________________________##########__________
______________________##########___,________________________##########__________
_,_ʭʭʭʭʭʭʭʭʭʭʭʭʭʭʭʭ______.________________________'_____________________________
___ʭ≡≡___±©©±_____ʭ______________________________________,___________________"__
__.ʭ_____________"ʭ_________╔════════╗__╔════════╗__╔════════╗__╔════════╗______
___ʭ______::______ʭ_________║~~~~~~~~║__║~~~~~~~~║__║~~~~~~~~║__║~~~~~~~~║____##
___ʭ______::______ʭ_________║~~~~~~~~║__║~~~~~~~~║__║~~~~~~~~║__║~~~~~~~~║____##
___ʭ"_____::______ʭ_________║~~~~~~~~║__║~~~~~~~~║__║~~~~~~~~║__║~~~~~~~~║_,__##
___ʭ_____::::_____ʭ,________╚════════╝__╚════════╝__╚════════╝__╚════════╝____##
_______:::__:::________________________________"______________________________##
_______:::_":::________"___________,_________________________________,________##
_"_____::::::::_____________╔════════╗__╔════════╗__╔════════╗__╔════════╗____##
____________________________║~~~~~~~~║__║~~~~~~~~║__║~~~~~~~~║__║~~~~~~~~║______
___.:____Ħ::Ħ____:__________║~~~~~~~~║__║~~~~~~~~║__║~~~~~~~~║__║~~~~~~~~║___.__
____:,____::_____:,_______._║~~~~~~~~║__║~~~~~~~~║_.║~~~~~~~~║__║~~~~~~~~║______
____::::::::::::::__________╚════════╝__╚════════╝__╚════════╝__╚════════╝______
____:_____::"____:________________________""___________________________"________
_________::::_________,____________________________,____________________________
__'_:ỻ__Π____Π__ỻ:_____________"___##########________________,_______________###
___________________________________##########________________________________###
"#;

const SMALL_RUIN_2: &str = r#"Null|Null|Null
##______________________________________________________________________########
##___,______ᘉᘈᘊ_______┌┬┬┬┬┬┬┬┬┬┬┬┬┬┬┬┐_________________________________########
____╔═════╦═══════╗___├______Ħ±Ħ______┤___╔══════╦═══════════╗________________##
____║≡≡___║_±°¤°±_║___├_┌───┐___┌───┐_┤"__║≡≡≡___║_______≡≡≡≡║________*_______##
____║_____║__:·:__║___├_│~~~│___│~~~│_┤___║_________________≡║__________________
____║________:·:__║___├_│~~~│___│~~~│_┤___║______║___________║__________________
____╠═__══╝__:·:__║___├_└───┘___└───┘_┤___╠════__╝______.____║__________________
____║________:·:__║___├_______________┤___║ᘉᘍᘈᘊ______________║____________,_____
____║_____________║___├┬┬┬┬┬┬Ħ_Ħ┬┬┬┬┬┬┤___║ᘈᘊ___________________________________
___'╚_____________╝_______________,'_____"║ᘉ____________________________________
__________:·:_______ᘉᘍᘈᘊ__________________║ᘍ_______________________~~~__________
##________:·:______ᘈᘍᘈᘊᘉᘍ__________________________:·:_&&________~~~~~~~~",_____
##________:·:_______ᘈᘊᘉᘍᘈ__________________________:·:&&&&______~~~~~~~~~~',____
##________:·:________ᘈᘊᘉ___________________________:·:_&&&_______~~~~~~~~~~.____
##________:·_··················_________,__________:·:__________~~~~~~~~~~______
__________:·······················________________________________~~~~~~~_______
___,'_____.·····_.·······_······.___________·______________________~~~______###
________________________________________________________'____________________###
#____________________________________________________________________________###
#####________________________________________________________________________###
"#;

const SMALL_RUIN_3: &str = r#"Null|Null|Null
######_______________________________________________________________________###
________________________________________________________________________________
__,____________________________________,,________________┌┬┬┬┬┬┬┬┬┬┬┬┬┬┬┬┬┬┬┬┐__
___'__╔═════════════════╦════════════════════════════╗___├___,_______________┤__
______║___│__±°¤°±__│___║≡≡≡≡≡≡≡≡_____________"______║,__├__┌────┐:·:┌────┐._┤__
______║___└─────────┘___║≡≡__________________________║___├__│~~~~│:·:│~~~~│__┤__
______║____:::::::::____║____________________________║___├__│~~~~│:·:│~~~~│__┤__
____,"║____:·:·:·:·:____║____________________________║___├__└────┘:·:└─~~~┘__┤__
______║____:¨:·:·:¨:____║,___________________________║___├________:·:_~~~~~__┤__
______║____:·:¨:¨:·:____╩____________.___________________├_.______:·:__~~~___┤__
______║____:¨:·:·:¨:_____________________________________├,________________,"┤__
______║_____"____________________________________________├┬┬┬┬┬┬┬Ħ___Ħ┬┬┬┬┬┬┬┤__
___.__║_________________________________________________________________________
______║________________________________________________.________________________
______╚══*,_________________══════__________══════______________________________
________"_____________________________________________________________ѧ_________
##___________________________________________'__________________________________
##__________________########__,_______________________________________________##
##________________###########_______________########__________________________##
##_______________#############__________################_________________#######
"#;

const SMALL_RUIN_0: &str = r#"
________________________________________________________________________________
________________________________________________________________________________
________________________________________________________________________________
________________________________________________________________________________
________________________________________________________________________________
________________________________________________________________________________
________________________________________________________________________________
________________________________________________________________________________
________________________________________________________________________________
________________________________________________________________________________
________________________________________________________________________________
________________________________________________________________________________
________________________________________________________________________________
________________________________________________________________________________
________________________________________________________________________________
________________________________________________________________________________
________________________________________________________________________________
________________________________________________________________________________
________________________________________________________________________________
________________________________________________________________________________
"#;

// ponds

const POND_1: &str = r#"Null|Null|Null
##########______________##################_______________________##########
#######__________________#################__________________________#######
##__________________________############_________._____________________####
##__,_________________.___________________________________________'____####
#_______________________________________________________________________###
##_________________________________________"__________┌─────┐____________##
______',_______________________________________________π____│______________
_______________________________________________________ঌ_⑁__│*_____________
______________,'~~~~~~~~~~~~~~~~~~_____________________ѧ__⑁_│___________###
##_________,~~~~~~~~~~~~~~~~~~~~~~~~~,______________________│___________###
###_____,~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~_______________⑁___│__________####
###_____~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~____________└─────┘__________####
##______~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~__________________________####
##______~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~_________________________###
________~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~_________________________
_______"~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~_____________",________
________~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~______________________
________'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~______________________
___________,~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~____'_____________________
##______________~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~___________________________##
##______.____________,'~~~~~~~~~~~~~~~~~~,______________________________###
##____________________________________________________________,_________###
###_____________________________________________________________________###
#######_______________###############_________________________________#####
########_____________###################_____________________________######
"#;

const POND_2: &str = r#"Null|Null|Null
###____________________________#############_________________________######
###______________________________#########___________________________######
###_,_______________.______",__________________~~~~~~~~~,___________.___###
___________┌───────────────────┐'____________~~~~~~~~~~~~~~~____________###
__________"│__::.:.:.:.:.:.::__│___________.~~~~~~~~~~~~~~~~~'___________##
___________│__ঌ____:___:_______│"__________~~~~~~~~~~~~~~~~~~______________
____.______│__ѧ_:_________:____│,__________~~~~~~~~~~~~~~~~~~~,________,___
__________________________________________~~~~~~~~~~~~~~~~~~~~~____________
#________________________________________,~~~~~~~~~~~~~~~~~~~~~____________
##______________________________________'~~~~~~~~~~~~~~~~~~~~~~'___________
###____'________________________________~~~~~~~~~~~~~~~~~~~~~~~~___________
###_______________________________,~~~~~~~~~~~~~~~~~~~~~~~~~~~~~'__________
###________________,_____~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~___"_______
###________________~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~____________
##______________~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~'____________
##_________.___~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~_____________
_______________~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~_____________
________________~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~______*____#
____,____________"'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~_________##
___________________'_,~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"________##
##____________________'___"_,~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~,_________##
###________________________________',____"~~~~~~~~~~~~~~~~~,__'__________##
###_____'_______________________________________"___________________,____##
#####___________##############__________________________###################
######_________#################_____________________######################
"#;

const POND_3: &str = r#"Null|Null|Null
###___################________________################_______________######
###____#############_____________"___________________________________######
###____________._______________________________________'_____&&&&_______###
##______",_________________________________'________________&&&&&&_________
##__________________________________________________________&&&&&&_________
##_________________,',"~~~~~~~~~~~~_____________.____________&&&.________##
#______________,'.','~~~~~~~~~~~~~~~~~~~_____________________,__________###
#___,_________'.","~~~~~~~~~~~~~~~~~~~~~~~~~~~~_________________________###
#_____________','~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~_______________________###
#_____________,',~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~_________________"___###
#_____________,"~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~_________________###
#______________*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~______________###
_______"________~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~_____________##
_________________~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~_______________
___________,______~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~_______________
______&&&_________~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~'__"_____'_________
_____&&&&&&__________~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~,'____________________
_____&&&&&&_______________~~~~~~~~~~~~~~~~~~~~~,"________________________##
_______&&&_______________________________________________________________##
_______________________________._______________________*_________________##
____'________,___________________________________________________________##
##______________________________________,_____________________________.__##
##_______________________________________"_______________________________##
#########___________##########___________________________________##########
###########________##############____________________________##############
"#;

const POND: [&str; 3] = [POND_1, POND_2, POND_3];

const ralette: &str = r#"
empty: ' . , ' * |
wall: ▒ |
other ▓ ░ ~ |
pipes:
═ ║ ╣ ╠ ╩ ╦ ╗ ╝ ╚ ╔ ╬
┐ └ ┴ ┬ ├ ─ ┼ ┘ ┌ ┤ │

ʬ ỻ Π Ħ ʭ                     
ж ѧ π
 
≡ ° × ¤ ¸ ¨ · ■ ¦ ± ¡ ø Ø ©

i ̾¡  ͔¡  ͊¡  ͛¡  ̷¡  ̸¡  ̚¡  ͆¡ ¡˞ ¡ˡ  ̢¡ ¡     

"#;

const TEMP: &str = r#"
________________________________________________________________________________
________________________________________________________________________________
________________________________________________________________________________
________________________________________________________________________________
________________________________________________________________________________
________________________________________________________________________________
________________________________________________________________________________
________________________________________________________________________________
________________________________________________________________________________
________________________________________________________________________________
________________________________________________________________________________
________________________________________________________________________________
________________________________________________________________________________
________________________________________________________________________________
________________________________________________________________________________
________________________________________________________________________________
________________________________________________________________________________
________________________________________________________________________________
________________________________________________________________________________
________________________________________________________________________________
"#;

const SMALL_RUINS: [&str; 3] = [SMALL_RUIN_1, SMALL_RUIN_2, SMALL_RUIN_3];

fn ch_to_enum(ch: char) -> Cells {
    match ch {
        '_' => Cells::Empty,
        '#' => Cells::Transparent,
        ',' => Cells::Grass1,
        '⚶' => Cells::TallGrass,
        '\'' => Cells::Grass2,
        '\"' => Cells::Grass3,
        '·' => Cells::Dirt1,
        '.' => Cells::Dirt2,
        ':' => Cells::Dirt3,
        '*' => Cells::Rock,
        '▒' => Cells::Wall,
        '▓' => Cells::Wall2,
        '█' => Cells::Wall3,
        '░' => Cells::Wall4,
        'ඉ' => Cells::Roots,
        '🬤' => Cells::Broken1,
        '🬗' => Cells::Broken2,
        '🬐' => Cells::Broken3,
        '🬑' => Cells::Broken4,
        '🬮' => Cells::Broken5,
        '🬡' => Cells::Broken6,
        ' ' => Cells::Floor,
        '▧' => Cells::Tile1,
        '▨' => Cells::Tile2,
        '▩' => Cells::Tile3,
        '~' => Cells::Water,
        '═' => Cells::MwH,
        '║' => Cells::MwV,
        '╣' => Cells::MwVL,
        '╠' => Cells::MwVR,
        '╩' => Cells::MwHU,
        '╦' => Cells::MwHD,
        '╝' => Cells::MwUL,
        '╚' => Cells::MwUR,
        '╗' => Cells::MwDL,
        '╔' => Cells::MwDR,
        '╬' => Cells::MwCR,
        '─' => Cells::SwH,
        '│' => Cells::SwV,
        '┤' => Cells::SwVL,
        '├' => Cells::SwVR,
        '┴' => Cells::SwHU,
        '┬' => Cells::SwHD,
        '┘' => Cells::SwUL,
        '└' => Cells::SwUR,
        '┐' => Cells::SwDL,
        '┌' => Cells::SwDR,
        '┼' => Cells::SwCR,
        '╟' => Cells::BsVR,
        '╢' => Cells::BsVL,
        '╤' => Cells::BsHD,
        '╧' => Cells::BsHU,
        '╭' => Cells::CurUL,
        '╮' => Cells::CurUR,
        '╰' => Cells::CurBL,
        '╯' => Cells::CurBR,
        '┆' => Cells::BknWV,
        '┄' => Cells::BknWH,
        '≡' => Cells::Cong,
        '°' => Cells::Deg,
        '×' => Cells::Mult,
        '¸' => Cells::Ced,
        '¨' => Cells::Diae,
        '■' => Cells::Blsq,
        '¦' => Cells::VBrk,
        '±' => Cells::PlMin,
        'ø' => Cells::SmZer,
        'Ø' => Cells::BZer,
        '©' => Cells::Cop,
        'Ħ' => Cells::DblBracedGate, //-------
        'ỻ' => Cells::BracedGate,
        'Π' => Cells::Arch,
        'ʭ' => Cells::Bricks,
        'ʬ' => Cells::Crops,
        'ѧ' => Cells::SmallCampfire,
        'Ѧ' => Cells::Campfire,
        'π' => Cells::Table,
        'ж' => Cells::Firewood,
        'ঌ' => Cells::FireSmoke,
        'Ʌ' => Cells::Tent,
        '🁢' => Cells::Bed,
        '&' => Cells::Bush,
        'ᘉ' => Cells::Bramble1,
        'ᘈ' => Cells::Bramble2,
        'ᘍ' => Cells::Bramble3,
        'ᘊ' => Cells::Bramble4,
        '{' => Cells::LBrce,
        '}' => Cells::RBrce,
        '(' => Cells::LParen,
        ')' => Cells::RParen,
        '¤' => Cells::GenCur,
        'o' => Cells::Item,
        'l' => Cells::Log,
        'c' => Cells::Clinic,
        'p' => Cells::GPost,
        's' => Cells::CPost,
        _ => Cells::Empty,
    }
}

pub fn parse_map(
    s_map: &str,
    mut cells: Vec<Vec<Cells>>,
) -> (
    Vec<Vec<Cells>>,
    HashMap<(usize, usize), NPCWrap>,
    HashMap<(usize, usize), Item>,
    HashMap<(usize, usize), EnvInter>,
) {
    // let mut cells: Vec<Vec<Cells>> = Vec::new();
    let mut rng = rand::thread_rng();
    let map_codet = s_map.lines().next().unwrap_or("");
    let map_code: Vec<&str> = map_codet.split("|").collect();
    let npc_types: Vec<&str> = map_code.clone()[0].split(" ").collect();
    let item_types: Vec<&str> = map_code.clone()[2].split(" ").collect();

    let data1 = fs::read_to_string("src/npcs/npc_names.json");
    //log::info!("{:?}", &data1);
    let names: Vec<String> = match data1 {
        Ok(content) => serde_json::from_str(&content).unwrap(),
        Err(e) => {
            log::info!("{:?}", e);
            Vec::new()
        }
    };

    let data2 = fs::read_to_string("src/npcs/npc_comms.json");
    //log::info!("{:?}", &data2);
    let comms: Vec<String> = match data2 {
        Ok(content) => serde_json::from_str(&content).unwrap(),
        Err(e) => {
            log::info!("{:?}", e);
            Vec::new()
        }
    };

    let data3 = fs::read_to_string("src/npcs/npc_convos.json");
    //log::info!("{:?}", &data3);
    let convos: Vec<Convo> = match data3 {
        Ok(content) => serde_json::from_str(&content).unwrap(),
        Err(e) => {
            log::info!("{:?}", e);
            Vec::new()
        }
    };

    let mut ncount = 0;
    let mut icount = 0;
    //let mut cells = vec![vec![Cells::Null; 150]; 50];
    let mut npcs = HashMap::new();
    let mut items = HashMap::new();
    let mut env_inters = HashMap::new();
    for (y, line) in s_map.lines().skip(1).enumerate() {
        for (x, ch) in line.chars().enumerate() {
            let cell = match ch {
                '_' => Cells::Empty,
                '#' => Cells::Transparent,
                ',' => Cells::Grass1,
                '⚶' => Cells::TallGrass,
                '\'' => Cells::Grass2,
                '\"' => Cells::Grass3,
                '·' => Cells::Dirt1,
                '.' => Cells::Dirt2,
                ':' => Cells::Dirt3,
                '*' => Cells::Rock,
                '▒' => Cells::Wall,
                '▓' => Cells::Wall2,
                '█' => Cells::Wall3,
                '░' => Cells::Wall4,
                'ඉ' => Cells::Roots,
                '🬤' => Cells::Broken1,
                '🬗' => Cells::Broken2,
                '🬐' => Cells::Broken3,
                '🬑' => Cells::Broken4,
                '🬮' => Cells::Broken5,
                '🬡' => Cells::Broken6,
                ' ' => Cells::Floor,
                '▧' => Cells::Tile1,
                '▨' => Cells::Tile2,
                '▩' => Cells::Tile3,
                '~' => Cells::Water,
                '═' => Cells::MwH,
                '║' => Cells::MwV,
                '╣' => Cells::MwVL,
                '╠' => Cells::MwVR,
                '╩' => Cells::MwHU,
                '╦' => Cells::MwHD,
                '╝' => Cells::MwUL,
                '╚' => Cells::MwUR,
                '╗' => Cells::MwDL,
                '╔' => Cells::MwDR,
                '╬' => Cells::MwCR,
                '─' => Cells::SwH,
                '│' => Cells::SwV,
                '┤' => Cells::SwVL,
                '├' => Cells::SwVR,
                '┴' => Cells::SwHU,
                '┬' => Cells::SwHD,
                '┘' => Cells::SwUL,
                '└' => Cells::SwUR,
                '┐' => Cells::SwDL,
                '┌' => Cells::SwDR,
                '┼' => Cells::SwCR,
                '╟' => Cells::BsVR,
                '╢' => Cells::BsVL,
                '╤' => Cells::BsHD,
                '╧' => Cells::BsHU,
                '╭' => Cells::CurUL,
                '╮' => Cells::CurUR,
                '╰' => Cells::CurBL,
                '╯' => Cells::CurBR,
                '┆' => Cells::BknWV,
                '┄' => Cells::BknWH,
                '≡' => Cells::Cong,
                '°' => Cells::Deg,
                '×' => Cells::Mult,
                '¸' => Cells::Ced,
                '¨' => Cells::Diae,
                '■' => Cells::Blsq,
                '¦' => Cells::VBrk,
                '±' => Cells::PlMin,
                'ø' => Cells::SmZer,
                'Ø' => Cells::BZer,
                '©' => Cells::Cop,
                'Ħ' => Cells::DblBracedGate, //-------
                'ỻ' => Cells::BracedGate,
                'Π' => Cells::Arch,
                'ʭ' => Cells::Bricks,
                'ʬ' => Cells::Crops,
                'ѧ' => Cells::SmallCampfire,
                'Ѧ' => Cells::Campfire,
                'π' => Cells::Table,
                'ṑ' => Cells::Jar,
                '⑁' => Cells::Chair,
                'Һ' => Cells::ChairRight1,
                'Ⴙ' => Cells::ChairRight2,
                'ж' => Cells::Firewood,
                'ঌ' => Cells::FireSmoke,
                '܀' => Cells::FireDiamond,
                'ஃ' => Cells::FireTri,
                'Ŧ' => Cells::Stand1,
                'Ÿ' => Cells::Stand2,
                'Ť' => Cells::Stand3,
                'ƃ' => Cells::StandBL,
                'ƌ' => Cells::StandDL,
                'Ƃ' => Cells::StandBS,
                'Ƌ' => Cells::StandDS,
                '◍' => Cells::CircleVL,
                '⏣' => Cells::CircleHex,
                '⌬' => Cells::CircleC,
                '⌹' => Cells::Drawers,
                '⌸' => Cells::Shelves,
                '⚱' => Cells::Vase,
                '𜲄' => Cells::LadderV,
                '𜲅' => Cells::LadderH,
                '𜲐' => Cells::TickV,
                '𜲑' => Cells::TickH,
                'ቋ' => Cells::Tech1,
                '🝻' => Cells::Tech2,
                '🜟' => Cells::Tech3,
                'ଏ' => Cells::Tech4,
                'Ҧ' => Cells::Tech5,
                'Ҹ' => Cells::Tech6,
                'Ҵ' => Cells::Tech7,
                'ౝ' => Cells::Tech8,
                '𜰔' => Cells::Tech9,
                '𜰓' => Cells::Tech10,
                '𜰉' => Cells::Tech11,
                '𜰊' => Cells::Tech12,
                '⛀' => Cells::Tech13,
                '⛁' => Cells::Tech14,
                '⛂' => Cells::Tech15,
                '⛃' => Cells::Tech16,
                'Ⴉ' => Cells::Tech17,
                'ቖ' => Cells::Relic1,
                '⚗' => Cells::Alembic,
                'ቷ' => Cells::OldWall1,
                'ቿ' => Cells::OldWall2,
                'ቨ' => Cells::OldWall3,
                'ቩ' => Cells::OldWall4,
                'ቭ' => Cells::OldWall5,
                '🀫' => Cells::CardTile1,
                '🀘' => Cells::CardTile2,
                '🀆' => Cells::CardTile3,
                '🀙' => Cells::CardTile4,
                // '' => Cells::,
                'Ʌ' => Cells::Tent,
                '🁢' => Cells::Bed,
                '&' => Cells::Bush,
                'ᘉ' => Cells::Bramble1,
                'ᘈ' => Cells::Bramble2,
                'ᘍ' => Cells::Bramble3,
                'ᘊ' => Cells::Bramble4,
                // '@' => Cells::NPCM,
                '{' => Cells::LBrce,
                '}' => Cells::RBrce,
                '(' => Cells::LParen,
                ')' => Cells::RParen,
                '¤' => Cells::GenCur,
                'o' => Cells::Item,
                'l' => Cells::Log,
                'c' => Cells::Clinic,
                'p' => Cells::GPost,
                's' => Cells::CPost,
                _ => Cells::Empty,
            };
            cells[y][x] = cell;
            if ch == '@' {
                let def_name = "Kevthony".to_string();
                match npc_types[ncount] {
                    "CommNPC" => {
                        //let com_def = vec!["Welcome to the caves!!".to_string(), "Theres a tonne of folk down here, lerger cities as you go into the cave.".to_string()];
                        let rnd_comms = {
                            let mut tvec = Vec::new();
                            for _ in 0..4 {
                                let tidx = rng.gen_range(0..comms.len());
                                tvec.push(comms[tidx].clone());
                            }
                            tvec
                        };
                        let name = names.choose(&mut rng).unwrap_or(&def_name.clone()).clone();
                        let t_comm = new_comm_npc(name.clone(), x, y, rnd_comms.clone());
                        npcs.insert((x, y), NPCWrap::CommNPC(t_comm.clone()));
                    }
                    "ConvNPC" => {
                        let name = names.choose(&mut rng).unwrap_or(&def_name.clone()).clone();
                        //let comms = vec!["Welcome to the caves!!".to_string(), "Theres a tonne of folk down here, lerger cities as you go into the cave.".to_string()];
                        let conv: Convo = convos
                            .choose(&mut rng)
                            .unwrap_or(&convos[0].clone())
                            .clone();
                        let t_comm = new_conv_npc(name.clone(), x, y, conv.clone());
                        npcs.insert((x, y), NPCWrap::ConvNPC(t_comm.clone()));
                    }
                    _ => todo!(),
                }
                ncount += 1;
            }
            if ch == 'O' {
                match item_types[icount] {
                    "HealthPotion" => {
                        let ti = Item::new_health_potion(x, y);
                        items.insert((x, y), ti.clone());
                    }
                    "Salve" => {
                        let ti = Item::new_salve(x, y);
                        items.insert((x, y), ti.clone());
                    }
                    "Dowel" => {
                        let ti = Item::new_dowel(x, y);
                        items.insert((x, y), ti.clone());
                    }
                    "SmallWoodShield" => {
                        let ti = Item::new_small_wood_shield(x, y);
                        items.insert((x, y), ti.clone());
                    }
                    "Apple" => {
                        let ti = Item::new_apple(x, y);
                        items.insert((x, y), ti.clone());
                    }
                    "BronzeClaymore" => {
                        let ti = Item::new_bronze_claymore(x, y);
                        items.insert((x, y), ti.clone());
                    }
                    "BronzeShortsword" => {
                        let ti = Item::new_bronze_shortsword(x, y);
                        items.insert((x, y), ti.clone());
                    }
                    "BronzeLongsword" => {
                        let ti = Item::new_bronze_longsword(x, y);
                        items.insert((x, y), ti.clone());
                    }
                    "BronzeLightAxe" => {
                        let ti = Item::new_bronze_light_axe(x, y);
                        items.insert((x, y), ti.clone());
                    }
                    "BronzeHeavyAxe" => {
                        let ti = Item::new_bronze_heavy_axe(x, y);
                        items.insert((x, y), ti.clone());
                    }
                    "BronzeWarAxe" => {
                        let ti = Item::new_bronze_war_axe(x, y);
                        items.insert((x, y), ti.clone());
                    }
                    "BronzePickHammer" => {
                        let ti = Item::new_bronze_pick_hammer(x, y);
                        items.insert((x, y), ti.clone());
                    }
                    "WoodStaff" => {
                        let ti = Item::new_wood_staff(x, y);
                        items.insert((x, y), ti.clone());
                    }
                    "LightArmour" => {
                        let ti = Item::new_light_armour(x, y);
                        items.insert((x, y), ti.clone());
                    }
                    _ => {
                        log::info!("itm {:?}", item_types[icount]);
                    }
                }
                icount += 1;
            }
            if ch == 'l' {
                env_inters.insert((x, y), EnvInter::Records);
            }
            if ch == 'p' {
                env_inters.insert((x, y), EnvInter::GuildPost);
            }
            if ch == 'c' {
                env_inters.insert((x, y), EnvInter::Clinic);
            }
            if ch == 'C' {
                env_inters.insert((x, y), EnvInter::Construction);
            }
            if ch == 's' {
                env_inters.insert((x, y), EnvInter::ChurchPost);
            }
            if ch == '℧' {
                env_inters.insert((x, y), EnvInter::Cauldron);
            }
            if ch == 'h' {
                env_inters.insert((x, y), EnvInter::Herbalist);
            }
            if ch == 'd' {
                env_inters.insert(
                    (x, y),
                    EnvInter::Door(Door::HLocked(rng.gen_range(0..10) as u8)),
                );
            }
            if ch == 'D' {
                env_inters.insert(
                    (x, y),
                    EnvInter::Door(Door::VLocked(rng.gen_range(0..10) as u8)),
                );
            }
        }
    }
    (cells, npcs, items, env_inters)
}

fn make_small_ruin_feature() -> (
    Vec<Vec<Cells>>,
    HashMap<(usize, usize), NPCWrap>,
    HashMap<(usize, usize), Item>,
    HashMap<(usize, usize), EnvInter>,
) {
    let cells = vec![vec![Cells::Empty; 80]; 20];
    let mut rng = rand::thread_rng();
    parse_map(SMALL_RUINS.choose(&mut rng).unwrap_or(&SMALL_RUIN_1), cells)
}

fn make_abandoned_shack() -> (
    Vec<Vec<Cells>>,
    HashMap<(usize, usize), NPCWrap>,
    HashMap<(usize, usize), Item>,
    HashMap<(usize, usize), EnvInter>,
) {
    let cells = vec![vec![Cells::Empty; 40]; 12];
    let mut rng = rand::thread_rng();
    parse_map(
        ABANDONED_SHACKS
            .choose(&mut rng)
            .unwrap_or(&ABANDONED_SHACK_1),
        cells,
    )
}

fn make_construction_feature() -> (
    Vec<Vec<Cells>>,
    HashMap<(usize, usize), NPCWrap>,
    HashMap<(usize, usize), Item>,
    HashMap<(usize, usize), EnvInter>,
) {
    let cells = vec![vec![Cells::Empty; 40]; 12];
    let mut rng = rand::thread_rng();
    parse_map(
        CONSTRUCTION.choose(&mut rng).unwrap_or(&CONSTRUCTION_1),
        cells,
    )
}

fn make_pond_feature() -> (
    Vec<Vec<Cells>>,
    HashMap<(usize, usize), NPCWrap>,
    HashMap<(usize, usize), Item>,
    HashMap<(usize, usize), EnvInter>,
) {
    let cells = vec![vec![Cells::Empty; 75]; 25];
    let mut rng = rand::thread_rng();
    parse_map(POND.choose(&mut rng).unwrap_or(&POND_1), cells)
}

#[derive(Clone, PartialEq, Eq, Copy, PartialOrd, Ord)]
enum Field {
    Normal,
    NormalTrans,
    InCornerUL,
    InCornerUR,
    InCornerDL,
    InCornerDR,
    OutCornerUL,
    OutCornerUR,
    OutCornerDL,
    OutCornerDR,
    HorzEdgeU,
    HorzEdgeD,
    VertEdgeL,
    VertEdgeR,
    Shrub,
    Empty,
    EmptyTrans,
    Null,
}

const UP_FULL: [Field; 6] = [
    Field::Normal,
    Field::InCornerDL,
    Field::InCornerDR,
    Field::HorzEdgeU,
    Field::Shrub,
    Field::NormalTrans,
];

const UP_LEFT: [Field; 3] = [Field::VertEdgeR, Field::InCornerUL, Field::OutCornerUR];

const UP_RIGHT: [Field; 3] = [Field::VertEdgeL, Field::InCornerUR, Field::OutCornerUL];

const UP_EMPTY: [Field; 5] = [
    Field::Empty,
    Field::EmptyTrans,
    Field::HorzEdgeD,
    Field::OutCornerDL,
    Field::OutCornerDR,
];

const LEFT_FULL: [Field; 6] = [
    Field::Normal,
    Field::NormalTrans,
    Field::InCornerUR,
    Field::InCornerDR,
    Field::VertEdgeL,
    Field::Shrub,
];

const LEFT_TOP: [Field; 3] = [Field::InCornerUL, Field::OutCornerDL, Field::HorzEdgeD];

const LEFT_BOTT: [Field; 3] = [Field::InCornerDL, Field::OutCornerUL, Field::HorzEdgeU];

const LEFT_EMPTY: [Field; 5] = [
    Field::Empty,
    Field::EmptyTrans,
    Field::VertEdgeR,
    Field::OutCornerDR,
    Field::OutCornerUR,
];

pub fn tile_to_chars(tile: &str) -> Vec<Vec<char>> {
    tile.trim()
        .lines()
        .map(|line| line.chars().collect())
        .collect()
}

fn build_field() -> String {
    let mut rng = rand::thread_rng();
    let mut cells = vec![vec![' '; 128]; 64];
    let mut temp = vec![vec![Field::Empty; 8]; 8];
    // temp[0][0] = Field::OutCornerUL;
    for j in (0..temp.len()) {
        for i in (0..temp[0].len()) {
            let up = if j > 0 { temp[j - 1][i] } else { Field::Null };
            let left = if i > 0 { temp[j][i - 1] } else { Field::Null };
            temp[j][i] = {
                match (up, left) {
                    (Field::Null, Field::Null) => Field::OutCornerUL,
                    (up, left) if j == temp.len() - 1 && i == temp[0].len() - 1 => {
                        if UP_EMPTY.contains(&up) {
                            Field::Empty
                        } else {
                            Field::OutCornerDR
                        }
                    }
                    (Field::Null, left) => {
                        if i == temp[0].len() - 1 && LEFT_BOTT.contains(&left) {
                            Field::OutCornerUR
                        } else if i == temp[0].len() - 1 && LEFT_EMPTY.contains(&left) {
                            Field::Empty
                        } else if LEFT_BOTT.contains(&left) {
                            *[
                                Field::HorzEdgeU,
                                Field::HorzEdgeU,
                                Field::HorzEdgeU,
                                Field::OutCornerUR,
                            ]
                            .choose(&mut rng)
                            .unwrap_or(&Field::HorzEdgeU)
                        } else if LEFT_EMPTY.contains(&left) {
                            Field::OutCornerUL
                        } else {
                            Field::Empty
                        }
                    }
                    (up, Field::Null) => {
                        if j == temp.len() - 1 && UP_RIGHT.contains(&up) {
                            Field::OutCornerDL
                        } else if j == temp.len() - 1 && UP_EMPTY.contains(&up) {
                            Field::Empty
                        } else if UP_RIGHT.contains(&up) {
                            *[
                                Field::VertEdgeL,
                                Field::VertEdgeL,
                                Field::VertEdgeL,
                                Field::OutCornerDL,
                            ]
                            .choose(&mut rng)
                            .unwrap_or(&Field::VertEdgeL)
                        } else {
                            Field::OutCornerUL
                        }
                    }
                    (up, left) if i == temp[0].len() - 1 => {
                        if UP_LEFT.contains(&up) && LEFT_FULL.contains(&left) {
                            Field::VertEdgeR
                        } else if UP_LEFT.contains(&up) && LEFT_TOP.contains(&left) {
                            Field::OutCornerDR
                        } else if UP_EMPTY.contains(&up) && LEFT_BOTT.contains(&left) {
                            Field::OutCornerUR
                        } else {
                            Field::Empty
                        }
                    }
                    (up, left) if j == temp.len() - 1 => {
                        if UP_FULL.contains(&up) && LEFT_TOP.contains(&left) {
                            Field::HorzEdgeD
                        } else if UP_LEFT.contains(&up) && LEFT_TOP.contains(&left) {
                            Field::OutCornerDR
                        } else if UP_RIGHT.contains(&up) && LEFT_EMPTY.contains(&left) {
                            Field::OutCornerDL
                        } else {
                            Field::Empty
                        }
                    }
                    (up, left) if UP_FULL.contains(&up) && LEFT_FULL.contains(&left) => *[
                        Field::Normal,
                        Field::Normal,
                        Field::Normal,
                        Field::NormalTrans,
                        Field::InCornerUL,
                        Field::Shrub,
                    ]
                    .choose(&mut rng)
                    .unwrap_or(&Field::Normal),
                    (up, left) if UP_FULL.contains(&up) && LEFT_TOP.contains(&left) => {
                        *[Field::HorzEdgeD, Field::InCornerUR]
                            .choose(&mut rng)
                            .unwrap_or(&Field::HorzEdgeD)
                    }
                    (up, left) if UP_EMPTY.contains(&up) && LEFT_BOTT.contains(&left) => {
                        *[Field::HorzEdgeU, Field::OutCornerUR]
                            .choose(&mut rng)
                            .unwrap_or(&Field::HorzEdgeU)
                    }
                    (up, left) if UP_EMPTY.contains(&up) && LEFT_EMPTY.contains(&left) => {
                        // *[Field::OutCornerUR]
                        //     .choose(&mut rng)
                        //     .unwrap_or(&Field::HorzEdgeU
                        Field::OutCornerUL
                    }
                    (up, left) if UP_LEFT.contains(&up) && LEFT_FULL.contains(&left) => {
                        *[Field::VertEdgeR, Field::InCornerDL]
                            .choose(&mut rng)
                            .unwrap_or(&Field::VertEdgeR)
                    }
                    (up, left) if UP_LEFT.contains(&up) && LEFT_TOP.contains(&left) => {
                        Field::OutCornerDR
                    }
                    (up, left) if UP_RIGHT.contains(&up) && LEFT_EMPTY.contains(&left) => {
                        *[Field::VertEdgeL, Field::OutCornerDL]
                            .choose(&mut rng)
                            .unwrap_or(&Field::VertEdgeL)
                    }
                    (up, left) if UP_RIGHT.contains(&up) && LEFT_BOTT.contains(&left) => {
                        Field::InCornerDR
                    }
                    _ => Field::EmptyTrans,
                }
                // Field::Null
            }
        }
    }
    for j in 0..temp.len() {
        for i in 0..temp[0].len() {
            let patch = match temp[j][i] {
                Field::Normal => GRASS_PATCH,
                Field::NormalTrans => GRASS_PATCH,
                Field::OutCornerUL => GRASS_OUT_CORNER_UL,
                Field::OutCornerUR => GRASS_OUT_CORNER_UR,
                Field::OutCornerDL => GRASS_OUT_CORNER_BL,
                Field::OutCornerDR => GRASS_OUT_CORNER_BR,
                Field::InCornerUL => GRASS_IN_CORNER_UL,
                Field::InCornerUR => GRASS_IN_CORNER_UR,
                Field::InCornerDL => GRASS_IN_CORNER_BL,
                Field::InCornerDR => GRASS_IN_CORNER_BR,
                Field::HorzEdgeU => GRASS_HORZ_U,
                Field::HorzEdgeD => GRASS_HORZ_B,
                Field::VertEdgeL => GRASS_VERT_L,
                Field::VertEdgeR => GRASS_VERT_R,
                Field::Empty => GRASS_EMPTY,
                Field::Shrub => SHRUB_PATCH,
                Field::EmptyTrans => GRASS_EMPTY_TRANS,
                _ => todo!(),
            };
            let patch_chars = tile_to_chars(patch);
            for y in 0..8 {
                for x in 0..16 {
                    cells[j * 8 + y][i * 16 + x] = patch_chars[y][x];
                }
            }
        }
    }
    std::iter::once("Null|Null|Null".to_string())
        .chain(cells.iter().map(|row| row.iter().collect::<String>()))
        .collect::<Vec<String>>()
        .join("\n")
}

fn make_field() -> (
    Vec<Vec<Cells>>,
    HashMap<(usize, usize), NPCWrap>,
    HashMap<(usize, usize), Item>,
    HashMap<(usize, usize), EnvInter>,
) {
    let cells = vec![vec![Cells::Empty; 128]; 64];
    parse_map(&build_field(), cells)
}

fn make_stream() -> (
    Vec<Vec<Cells>>,
    HashMap<(usize, usize), NPCWrap>,
    HashMap<(usize, usize), Item>,
    HashMap<(usize, usize), EnvInter>,
) {
    let cells = vec![vec![Cells::Empty; 128]; 64];
    parse_map(&build_stream(), cells)
}

#[derive(Clone, Debug, PartialEq)]
pub struct Feature {
    pub ftype: FeatureType,
    pub pos: (i16, i16),
    pub map: Vec<Vec<Cells>>,
    pub items: HashMap<(usize, usize), Item>,
    pub npcs: HashMap<(usize, usize), NPCWrap>,
    pub env_inters: HashMap<(usize, usize), EnvInter>,
    pub cont_sent: bool,
    pub hermit: bool,
    pub hermit_pos: (usize, usize),
    pub hermit_map: Vec<Vec<Cells>>,
}

impl Feature {
    pub fn place_hermit(&mut self) {
        for j in (0..self.map.len() - 6) {
            for i in (0..self.map[0].len() - 10) {
                let check = {
                    let mut ch = true;
                    for jj in j..(j + 6) {
                        if !ch {
                            break;
                        }
                        for ii in i..(i + 10) {
                            if self.map[jj][ii] != Cells::Empty {
                                ch = false;
                                break;
                            }
                        }
                    }
                    ch
                };
                if check {
                    self.hermit_pos = (i, j);
                    break;
                }
            }
        }
    }

    pub fn place_hermit_parts(&mut self) {
        let mut map = self.map.clone();
        let hermit = HERMIT_1;
        let mut items = HashMap::new();
        let mut env_inters = HashMap::new();
        let mut scroll = false;
        for (j, line) in hermit.lines().enumerate() {
            for (i, ch) in line.chars().enumerate() {
                match ch {
                    'x' => {
                        env_inters.insert(
                            (self.hermit_pos.0 + i, self.hermit_pos.1 + j),
                            EnvInter::Hermit,
                        );
                    }
                    'o' if !scroll => {
                        items.insert(
                            (self.hermit_pos.0 + i, self.hermit_pos.1 + j),
                            Item::new_scroll(self.hermit_pos.0 + i, self.hermit_pos.1 + j),
                        );
                        scroll = true;
                    }
                    'o' => {
                        items.insert(
                            (self.hermit_pos.0 + i, self.hermit_pos.1 + j),
                            rand_hermit_item(self.hermit_pos.0 + i, self.hermit_pos.1 + j),
                        );
                    }
                    _ => {}
                }
                map[self.hermit_pos.1 + j][self.hermit_pos.0 + i] = ch_to_enum(ch);
            }
        }
        self.items = items;
        self.env_inters = env_inters;
        self.hermit_map = map;
    }
}

pub struct Features {
    features: HashMap<(i16, i16), Feature>,
}

impl Features {
    pub fn new() -> Self {
        Self {
            features: HashMap::new(),
        }
    }

    pub fn get_feature_positions(&self) -> Vec<String> {
        let mut feat_vec = Vec::new();
        for (pos, f) in self.features.clone() {
            feat_vec.push(format!("({}, {}): {:?}", pos.0, pos.1, f.ftype));
        }
        feat_vec
    }

    pub fn new_rand_feature(&mut self, pos: (i16, i16)) {
        let mut rng = rand::thread_rng();
        // let choice = *[
        //     FeatureType::AbandonedShack,
        //     FeatureType::Field,
        //     FeatureType::Ruin,
        //     FeatureType::Stream,
        //     FeatureType::Construction,
        //     FeatureType::Pond,
        // ]
        // .choose(&mut rng)
        // .unwrap_or(&FeatureType::AbandonedShack);
        let choice = FeatureType::Pond;
        match choice {
            FeatureType::AbandonedShack => self.new_abandoned_shack(pos),
            FeatureType::Field => self.new_field_feature(pos),
            FeatureType::Ruin => self.new_small_ruin_feature(pos),
            FeatureType::Stream => self.new_stream_feature(pos),
            FeatureType::Construction => self.new_construction_feature(pos),
            FeatureType::Pond => self.new_pond_feature(pos),
            _ => self.new_abandoned_shack(pos),
        }
    }

    pub fn new_small_ruin_feature(&mut self, pos: (i16, i16)) {
        let (map, npcs, items, env_inters) = make_small_ruin_feature();
        self.features.insert(
            pos,
            Feature {
                ftype: FeatureType::Ruin,
                pos,
                map,
                items,
                npcs,
                env_inters,
                cont_sent: false,
                hermit: false,
                hermit_pos: (0, 0),
                hermit_map: Vec::new(),
            },
        );
    }

    pub fn new_construction_feature(&mut self, pos: (i16, i16)) {
        let (map, npcs, items, env_inters) = make_construction_feature();
        self.features.insert(
            pos,
            Feature {
                ftype: FeatureType::Construction,
                pos,
                map,
                items,
                npcs,
                env_inters,
                cont_sent: false,
                hermit: false,
                hermit_pos: (0, 0),
                hermit_map: Vec::new(),
            },
        );
    }

    pub fn new_pond_feature(&mut self, pos: (i16, i16)) {
        let (map, npcs, items, env_inters) = make_pond_feature();
        self.features.insert(
            pos,
            Feature {
                ftype: FeatureType::Pond,
                pos,
                map,
                items,
                npcs,
                env_inters,
                cont_sent: false,
                hermit: false,
                hermit_pos: (0, 0),
                hermit_map: Vec::new(),
            },
        );
    }

    pub fn new_field_feature(&mut self, pos: (i16, i16)) {
        let (map, npcs, items, env_inters) = make_field();
        self.features.insert(
            pos,
            Feature {
                ftype: FeatureType::Field,
                pos,
                map,
                items,
                npcs,
                env_inters,
                cont_sent: false,
                hermit: false,
                hermit_pos: (0, 0),
                hermit_map: Vec::new(),
            },
        );
    }

    pub fn new_stream_feature(&mut self, pos: (i16, i16)) {
        let (map, npcs, items, env_inters) = make_stream();
        self.features.insert(
            pos,
            Feature {
                ftype: FeatureType::Stream,
                pos,
                map,
                items,
                npcs,
                env_inters,
                cont_sent: false,
                hermit: false,
                hermit_pos: (0, 0),
                hermit_map: Vec::new(),
            },
        );
    }

    pub fn new_abandoned_shack(&mut self, pos: (i16, i16)) {
        let (map, npcs, items, env_inters) = make_abandoned_shack();
        self.features.insert(
            pos,
            Feature {
                ftype: FeatureType::AbandonedShack,
                pos,
                map,
                items,
                npcs,
                env_inters,
                cont_sent: false,
                hermit: false,
                hermit_pos: (0, 0),
                hermit_map: Vec::new(),
            },
        );
    }

    pub fn check_location(&self, bpos: (i16, i16), rad: u16) -> Option<Feature> {
        for (spos, s) in &self.features {
            let xx = (spos.0 - bpos.0 * -1) as i32;
            let yy = (spos.1 - bpos.1 * -1) as i32;
            let hyp = ((xx.pow(2) + yy.pow(2)) as f64).sqrt() as u64;
            if hyp <= rad.into() {
                return Some(s.clone());
            }
        }
        return None;
    }

    pub fn update_feature(&mut self, feature: Feature) {
        self.features.insert(feature.pos, feature);
    }

    pub fn feature_check(&mut self, pos: (i16, i16)) -> bool {
        let dir = (pos.0 / pos.0.abs(), pos.1 / pos.1.abs());
        let space = {
            match dir {
                (x, y) if x >= 0 && y >= 0 => (((pos.0 + 800), (pos.1 + 800)), pos),
                (x, y) if x < 0 && y >= 0 => (((pos.0 - 800), (pos.1 + 800)), pos),
                (x, y) if x >= 0 && y < 0 => (((pos.0 + 800), (pos.1 - 800)), pos),
                (x, y) if x < 0 && y < 0 => (((pos.0 - 800), (pos.1 - 800)), pos),
                _ => todo!(),
            }
        };
        for (k, _) in self.features.clone() {
            let xrange: Vec<i16> = {
                let mut xa = space.0 .0;
                let mut xb = space.1 .0;
                if xa > xb {
                    std::mem::swap(&mut xa, &mut xb);
                }
                (xa..xb).collect()
            };
            let yrange: Vec<i16> = {
                let mut ya = space.0 .0;
                let mut yb = space.1 .0;
                if ya > yb {
                    std::mem::swap(&mut ya, &mut yb);
                }
                (ya..yb).collect()
            };

            if xrange.contains(&k.0) && yrange.contains(&k.1) {
                return false;
            };
        }
        true
    }
}
